package uk.co.ziazoo.injector
{
	import de.polygonal.ds.TreeNode;
	
	import flash.utils.describeType;
	import flash.utils.getDefinitionByName;

	public class ReflectionParser implements IParser, IMapper
	{
		private var _config:IMappingConfiguration;
		private var _maps:Array;
		
		public function ReflectionParser( config:IMappingConfiguration )
		{
			_config = config;
			_maps = new Array();
			_config.create( this );
		}
		
		public function map( clazz:Class, provider:Class ):IMap
		{
			var map:IMap = new Map( clazz, provider );
			_maps.push( map );
			return map;
		}
		
		public function buildDependencyTree( entryPoint:Class ):void
		{
			var node:TreeNode = createNode( entryPoint );
			trace( node );
		}
		
		internal function createNode( clazz:Class, parent:TreeNode = null ):TreeNode
		{
			var node:TreeNode = new TreeNode( clazz, parent );
			
			for each( var accessor:XML in describeType( clazz ).factory.accessor )
			{
				if( accessor.hasOwnProperty( "metadata" ) )
				{
					for each( var metadata:XML in accessor.metadata )
					{
						if( metadata.@name )
						{
							createNode( getClass( accessor.@type ), node );
						}
					}
				}
			}
			return node;
		}
		
		internal function getClass( reflectedName:String ):Class
		{
			var name:String = reflectedName.replace( "::", "." );
			return getDefinitionByName( name ) as Class;
		}
		
		internal function getProvider( clazzName:String ):Class
		{
			return null;
		}
	}
}
import uk.co.ziazoo.injector.IMap;

class Map implements IMap
{
	private var _clazz:Class;
	private var _provider:Class;
	
	public function Map( clazz:Class, provider:Class )
	{
		_clazz = clazz;
		_provider = provider;
	}
	
	public function get provider():Class
	{
		return _provider;
	}
	
	public function get clazz():Class
	{
		return _clazz;
	}	
}



